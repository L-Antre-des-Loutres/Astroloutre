---
// Composant : PlayerTop.astro


import {formatMinecraftPlayTime} from "../../formater/MinecraftPlayTimeFormater";
import {formatNumber} from "../../formater/NumberFormater";
const {
    apiLink = 'https://otterlyapi.antredesloutres.fr/api/joueurs/stats-serveur/total-stats'
} = Astro.props;

interface PlayerStatsInterface {
    compte_id: number;
    playername: string;
    tmps_jeux: number;
    nb_mort: number;
    nb_kills: number;
    nb_playerkill: number;
    nb_blocs_detr: number;
    nb_blocs_pose: number;
    dist_total: number;
    dist_pieds: number;
    dist_elytres: number;
    dist_vol: number;
    dern_enregistrment: string; // ISO date string
}

const response = await fetch(apiLink);
const json = await response.json();

// Récupère le tableau réel dans `data`
const data: PlayerStatsInterface[] = json.data;

if (!data || data.length === 0) {
    throw new Error("Aucune donnée reçue de l'API !");
}

let topPlayerHours = data[0];
let topPlayerKills = data[0];
let topPlayerDistance = data[0];
let topPlayerKillsPerPlayer = data[0];
let topPlayerTimeDeathRatio = data[0];

for (let i = 0; i < data.length; i++) {
    const tmps_jeux = Number(data[i].tmps_jeux);
    const nb_kills = Number(data[i].nb_kills);
    const dist_total = Number(data[i].dist_total);
    const nb_playerkill = Number(data[i].nb_playerkill);
    const nb_mort = Number(data[i].nb_mort);

    // Joueur avec le plus d'heures
    if (tmps_jeux > Number(topPlayerHours.tmps_jeux)) {
        topPlayerHours = data[i];
    }

    // Joueur avec le plus de kills
    if (nb_kills > Number(topPlayerKills.nb_kills)) {
        topPlayerKills = data[i];
    }

    // Joueur avec la plus grande distance parcourue
    if (dist_total > Number(topPlayerDistance.dist_total)) {
        topPlayerDistance = data[i];
    }

    // Joueur avec le plus de player kills
    if (nb_playerkill > Number(topPlayerKillsPerPlayer.nb_playerkill)) {
        topPlayerKillsPerPlayer = data[i];
    }

// Joueur avec le meilleur ratio morts / heures de jeu
    if (tmps_jeux > 0) {
        const heures_jeu = formatMinecraftPlayTime(tmps_jeux) // conversion ticks → heures

        // Ignore les joueurs avec un temps de jeu trop court
        if (heures_jeu > 500) {

            const ratio = nb_mort / heures_jeu;
            const topHeures = formatMinecraftPlayTime(Number(topPlayerTimeDeathRatio.tmps_jeux));
            const topRatio = Number(topPlayerTimeDeathRatio.nb_mort) / topHeures;

            if (ratio > 0 && ratio < topRatio) {
                topPlayerTimeDeathRatio = data[i];
            }
        }
    }
}

// Récupére les statisitiques pour le moddée seulement :
const apiLinkModded = 'https://otterlyapi.antredesloutres.fr/api/joueurs/stats-serveur/total-stats-only-modded-server';
const responseModded = await fetch(apiLinkModded);
const jsonModded = await responseModded.json();

// Récupère le tableau réel dans `data`
const dataModded: PlayerStatsInterface[] = jsonModded.data;

if (!dataModded || data.length === 0) {
    throw new Error("Aucune donnée reçue de l'API !");
}

let topPlayerHoursModded = dataModded[0];

for (let i = 0; i < dataModded.length; i++) {
    const tmps_jeux = Number(dataModded[i].tmps_jeux);

    if (tmps_jeux > Number(topPlayerHoursModded.tmps_jeux)) {
        topPlayerHoursModded = dataModded[i];
    }
}


const stats = {
    hours: {
        playerUUID: topPlayerHours.compte_id,
        skinPose: "default",
        skinRender: "full",
        title: 'Joueur avec le plus d\'heures',
        leftTitle: 'À propos',
        leftBody: `${topPlayerHours.playername} ce joueur a passé énormément d\'heures à farmer, construire et explorer (faudrait peut-être lui dire que ce n'est pas le monde réel).`,
        rightTitle: 'Chiffres clés',
        rightBody: `<ul>
            <li><b class="soft-bold">Heures</b> : ${formatMinecraftPlayTime(topPlayerHours.tmps_jeux)}</li>
            <li><b class="soft-bold">Kills</b> : ${topPlayerHours.nb_kills}</li>
            <li><b class="soft-bold">Distance</b> : ${formatNumber(topPlayerHours.dist_total / 1000)} blocs</li>
        </ul>`
    },
    hoursModded: {
        playerUUID: topPlayerHoursModded.compte_id,
        skinPose: "pointing",
        skinRender: "full",
        title: 'Joueur avec le plus d\'heures en modée',
        leftTitle: 'À propos',
        leftBody: `${topPlayerHoursModded.playername} ne joue qu'avec des mods (Il doit s'ennuyer sur la vanilla).`,
        rightTitle: 'Chiffres clés',
        rightBody: `<ul>
            <li><b class="soft-bold">Heures</b> : ${formatMinecraftPlayTime(topPlayerHoursModded.tmps_jeux)}</li>
            <li><b class="soft-bold">Kills</b> : ${topPlayerHoursModded.nb_kills}</li>
            <li><b class="soft-bold">Distance</b> : ${formatNumber(topPlayerHoursModded.dist_total)} blocs</li>
        </ul>`
    },
    kills: {
        playerUUID: topPlayerKills.compte_id,
        skinPose: "lunging",
        skinRender: "full",
        title: 'Joueur avec le plus de kills',
        leftTitle: 'Playstyle',
        leftBody: `${topPlayerKills.playername} il est un tireur d\'élite, opportuniste en mêlée, ou il a juste une farm à mob`,
        rightTitle: 'Stats offensives',
        rightBody: `<ul>
            <li><b class="soft-bold">Kills</b> : ${topPlayerKills.nb_kills}</li>
            <li><b class="soft-bold">Kills de joueurs</b> : ${topPlayerKills.nb_playerkill}</li>
            <li><b class="soft-bold">K/D</b> : ${(topPlayerKills.nb_kills / Math.max(1, topPlayerKills.nb_mort)).toFixed(2)}</li>
        </ul>`
    },
    killsPerPlayer: {
        playerUUID: topPlayerKillsPerPlayer.compte_id,
        skinPose: "crouching",
        skinRender: "full",
        title: `Le joueur avec le plus de kills de joueur`,
        leftTitle: "L'assasin des peupliers",
        leftBody: `Si ${topPlayerKillsPerPlayer.playername} pouvait arrêter de tuer nos joueurs...`,
        rightTitle: 'Stats offensives',
        rightBody: `<ul>
            <li><b class="soft-bold">Kills</b> : ${topPlayerKillsPerPlayer.nb_kills}</li>
            <li><b class="soft-bold">Kills de joueurs</b> : ${topPlayerKillsPerPlayer.nb_playerkill}</li>
            <li><b class="soft-bold">K/D</b> : ${(topPlayerKillsPerPlayer.nb_kills / Math.max(1, topPlayerKills.nb_mort)).toFixed(2)}</li>
        </ul>`
    },
    distance: {
        playerUUID: topPlayerDistance.compte_id,
        skinPose: "kicking",
        skinRender: "full",
        title: `Le joueur avec le plus de distance parcourue`,
        leftTitle: 'Explorateur',
        leftBody: `${topPlayerDistance.playername} est toujours en mouvement — il aime cartographier et découvrir (ou perdre son temps en marchant sans but).`,
        rightTitle: 'Kilométrage',
        rightBody: `<ul>
            <li><b class="soft-bold">Distance</b> : ${formatNumber(topPlayerDistance.dist_total)} blocs</li>
            <li><b class="soft-bold">Voyages (à pied)</b> : ${formatNumber(topPlayerDistance.dist_pieds)} blocs</li>
            <li><b class="soft-bold">Distance en élytras</b> : ${formatNumber(topPlayerDistance.dist_elytres)} blocs</li>
        </ul>`
    },
    timeDeathRatio: {
        playerUUID: topPlayerTimeDeathRatio.compte_id,
        skinPose: "relaxing",
        skinRender: "full",
        title: `Le joueur avec le meilleur ratio M/H de : (Morts par Heures)`,
        leftTitle: `Trop de talent pour mourrir`,
        leftBody: `${topPlayerTimeDeathRatio.playername} a vraiment trop de talent pour mourrir (il est juste h24 AFK)`,
        rightTitle: 'Chiffres clés',
        rightBody: `<ul>
            <li><b class="soft-bold">Heures</b> : ${formatMinecraftPlayTime(topPlayerTimeDeathRatio.tmps_jeux)}</li>
            <li><b class="soft-bold">Morts</b> : ${topPlayerTimeDeathRatio.nb_mort}</li>
            <li><b class="soft-bold">Ratio</b> Mort / Temps de jeux : ${formatNumber(formatMinecraftPlayTime(topPlayerTimeDeathRatio.tmps_jeux) / topPlayerTimeDeathRatio.nb_mort)}</li>
        </ul>`
    }
};

---

<div class="playertop" role="region" aria-label="Top joueur">
    <div class="stats-select">
        <button class="stat-btn" data-action="prev" aria-label="Stat précédente">⮜</button>
        <h2 class="title">Joueur avec le plus d'heures</h2>
        <button class="stat-btn" data-action="next" aria-label="Stat suivante">➤</button>
    </div>

    <!-- Trois colonnes : side-text | playerskin | side-text -->
    <div class="content">
        <div class="side-text left">
            <h3 class="subtitle">Chargement en cours ...</h3>
            <div class="body">Minecraft moddée > La Vanilla</div>
        </div>

        <div class="playerskin" aria-hidden="false">
            <img src="" alt="Skin du joueur"/>
        </div>

        <div class="side-text right">
            <h3 class="subtitle">Chargement en cours ...</h3>
            <div class="body">
                <ul>
                    <li>La loutre charge la page</li>
                    <li>Patiente un peu !</li>
                    <li>PS : Coco est gros</li>
                </ul>
            </div>
        </div>
    </div>
</div>

<style>

    .soft-bold {
        color: black;
        font-weight: 500; /* ou 400 pour normal */
    }


    .playertop {
        max-width: 1100px;
        margin: 1.5rem auto;
    }

    /* Ici, c'est la partie selection de la statistique */
    .stats-select {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        margin-bottom: 1rem;
        position: relative;
    }

    .title {
        width: 20em;
        font-size: 1.125rem;
        font-weight: 600;
        margin: 0;
        text-align: center;
    }

    .stat-btn {
        background: transparent;
        font-size: 2em;
        padding: 0.45rem 0.7rem;
        cursor: pointer;
        font-weight: 600;
    }

    /* Fin de la partie selection de la statistique */

    /* Trois colonnes : side-text | playerskin | side-text */
    .content {
        display: flex;
        gap: 1rem;
        align-items: center;
        justify-content: space-between;
    }

    /* Pour les textes sur les cotés */
    .side-text {
        flex: 1 1 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        padding: 0.75rem;
        min-width: 160px;
    }

    .side-text .subtitle {
        margin: 0 0 0.4rem 0;
        font-size: 1.5rem;
        font-weight: bolder;
        animation: colorShift 10s infinite;
    }

    .side-text .body {
        font-size: 1rem;
    }

    /* Pour le playerskin */
    .playerskin {
        flex: 0 0 360px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0.4rem;
    }

    .playerskin img {
        height: 400px;
        width: auto;
        max-width: 500px;
        object-fit: contain;
        filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.5));
    }

    /* Fin du CSS pour les trois colonnes */

    /* Responsive : sur petits écrans on empile */
    @media (max-width: 820px) {
        .content {
            flex-direction: column;
        }

        .playerskin {
            order: 0;
        }

        .side-text {
            order: 1;
        }

        .playerskin img {
            width: 260px;
        }
    }

    @media (max-width: 420px) {
        .playerskin img {
            width: 200px;
        }

        .title {
            font-size: 1rem;
        }
    }

    /* Fin du responsive */

    /* Variables */
    @keyframes colorShift {
        0% {
            color: #e4bc71;
        }
        33% {
            color: #FFB347;
        }
        66% {
            color: #FF8C42;
        }
        100% {
            color: #eac47c;
        }
    }

    /* Fin des variables */
</style>

<script define:vars={{stats}}>
    window.addEventListener('DOMContentLoaded', () => {
        // Récupération des champs
        const title = document.querySelector('.title');
        const left = document.querySelector('.side-text.left .subtitle');
        const leftBody = document.querySelector('.side-text.left .body');
        const right = document.querySelector('.side-text.right .subtitle');
        const rightBody = document.querySelector('.side-text.right .body');
        const playerskinImg = document.querySelector('.playerskin img');

        const btnPrev = document.querySelector('.stat-btn[data-action="prev"]');
        const btnNext = document.querySelector('.stat-btn[data-action="next"]');
        const keys = Object.keys(stats);
        let currentIndex = 0;

        const preloaded = {};

        function buildUrl(playerUUID, skinPose, skinRender) {
            return `https://starlightskins.lunareclipse.studio/render/${skinPose}/${playerUUID}/${skinRender}`;
        }

        // Précharge toutes les images et renvoie une promesse
        function preloadAll() {
            const promises = keys.map((k) => {
                const s = stats[k];
                const url = buildUrl(s.playerUUID, s.skinPose, s.skinRender);
                preloaded[k] = {img: null, status: 'pending', url};

                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        preloaded[k].img = img;
                        preloaded[k].status = 'loaded';
                        resolve({key: k, ok: true});
                    };
                    img.onerror = () => {
                        preloaded[k].img = null;
                        preloaded[k].status = 'error';
                        resolve({key: k, ok: false});
                    };
                    img.src = url;
                });
            });

            return Promise.all(promises);
        }

        // Remplace l'image par l'image préchargée si possible, sinon par l'URL directe
        function showImageForKey(key) {
            if (!playerskinImg) return;
            // Logique de changement d'image
            const entry = preloaded[key];
            const targetSrc = (entry && entry.status === 'loaded' && entry.img && entry.img.src) ? entry.img.src : (entry ? entry.url : buildUrl(stats[key].playerUUID, stats[key].skinPose, stats[key].skinRender));

            // Gère l'animation de transition pour l'image
            playerskinImg.style.transition = 'opacity 220ms ease';
            playerskinImg.style.opacity = '0';

            // Au cas où l'image actuelle est la même src que targetSrc, forcer un repaint en utilisant setTimeout
            setTimeout(() => {
                playerskinImg.src = targetSrc;
            }, 220);

            // Remet l'opacité normal
            const onLoad = () => {
                playerskinImg.style.opacity = '1';
                playerskinImg.removeEventListener('load', onLoad);
            };
            playerskinImg.addEventListener('load', onLoad);
        }

        // Fonction pour mettre à jour les champs de texte ainsi que le playerskin
        function setActiveByKey(key) {
            const s = stats[key];
            if (!s) return;
            if (title) title.textContent = s.title;
            if (left) left.textContent = s.leftTitle;
            if (leftBody) leftBody.innerHTML = s.leftBody;
            if (right) right.textContent = s.rightTitle;
            if (rightBody) rightBody.innerHTML = s.rightBody;
            showImageForKey(key);
        }

        // Logique des boutons pour la navigation
        btnPrev?.addEventListener('click', () => {
            currentIndex = (currentIndex - 1 + keys.length) % keys.length;
            setActiveByKey(keys[currentIndex]);
        });
        btnNext?.addEventListener('click', () => {
            currentIndex = (currentIndex + 1) % keys.length;
            setActiveByKey(keys[currentIndex]);
        });

        // Fonction pour désactiver les boutons de navigation, nottament au chargement initial pour que les images chargent
        function setNavDisabled(disabled) {
            if (btnPrev) btnPrev.disabled = disabled;
            if (btnNext) btnNext.disabled = disabled;
        }

        // Start preload
        setNavDisabled(true);
        preloadAll().then((results) => {
            // Preload fini, on peut activer les boutons de navigation
            setNavDisabled(false);
            setActiveByKey(keys[currentIndex]);
        });
    });
</script>